<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Witch's Potion Recipe Game</title>
  <style>
    :root {
      --bg0: #0b0f19;
      --bg1: #1a0a3e;
      --accent: #5eff00;
      --accent2: #b66dff;
      --danger: #ff3b30;
      --text: #e9e9f0;
    }

    html, body { height: 100%; margin: 0; background: radial-gradient(120% 120% at 50% 100%, var(--bg1), var(--bg0)); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Arial, Apple Color Emoji, Segoe UI Emoji; overscroll-behavior: none; }

    .wrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas { display: block; background: transparent; touch-action: none; cursor: pointer; }

    .hud { position: fixed; inset: 0; pointer-events: none; }
    .score { position: absolute; top: env(safe-area-inset-top, 12px); left: 12px; padding: 6px 10px; border-radius: 10px; backdrop-filter: blur(6px); background: #0006; font-weight: 700; letter-spacing: 0.5px; box-shadow: 0 4px 16px #0007; user-select: none; }
    .hi { margin-left: 8px; opacity: .75; font-weight: 600; }
    .lives { font-size: 24px; letter-spacing: 2px; }
    .timer { font-size: 18px; font-weight: 700; color: var(--accent); }
    
    .recipe-hud { position: absolute; top: 60px; left: 50%; transform: translateX(-50%); display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 12px; backdrop-filter: blur(6px); background: #0006; box-shadow: 0 4px 16px #0007; font-size: 14px; font-weight: 700; max-width: 90%; }
    .recipe-hud .icon { width: 24px; height: 24px; }
    .recipe-hud .separator { opacity: 0.5; font-size: 20px; }

    .topbar { position: absolute; top: env(safe-area-inset-top, 12px); right: 12px; display: flex; align-items: center; gap: 16px; pointer-events: auto; z-index: 5; }
    .iconbtn { appearance: none; border: 0; width: 36px; height: 36px; border-radius: 50%; background: radial-gradient(120% 120% at 30% 20%, #7f5cff, #4a2fff); color: #fff; font-size: 18px; font-weight: 900; cursor: pointer; box-shadow: 0 6px 16px #0008, inset 0 0 0 1px #ffffff33; display: grid; place-items: center; }
    .iconbtn:active { transform: translateY(1px); }

    .overlay { position: fixed; inset: 0; display: grid; place-items: center; background: linear-gradient(180deg, #0008, #0004); backdrop-filter: blur(3px); z-index: 4; }
    .panel { pointer-events: auto; text-align: center; padding: 18px 20px; border-radius: 16px; background: #0c112480; border: 1px solid #ffffff18; box-shadow: 0 10px 30px #0009; max-width: min(90vw, 420px); }
    .title { font-size: 18px; margin-bottom: 10px; font-weight: 800; }
    .sub { opacity: .8; font-size: 13px; margin-bottom: 14px; }
    .btn { margin-top: 6px; appearance: none; border: 0; border-radius: 14px; background: linear-gradient(180deg, var(--accent2), #6a37ff); color: white; padding: 12px 16px; font-weight: 800; letter-spacing: .4px; cursor: pointer; box-shadow: 0 8px 18px #652bff55, inset 0 0 0 1px #ffffff30; }
    .btn:active { transform: translateY(1px); }

    .settings-grid { display: grid; grid-template-columns: auto 1fr auto; gap: 10px 15px; align-items: center; text-align: left; margin: 20px 0; font-size: 13px; }
    .settings-grid label { font-weight: 600; opacity: 0.9; }
    .settings-grid .value { font-weight: 700; color: var(--accent3); min-width: 40px; text-align: right; }
    input[type=range] { width: 100%; height: 6px; background: #0005; border-radius: 3px; cursor: pointer; appearance: none; }
    input[type=range]::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--accent2); border: 2px solid #fff; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="cv" width="360" height="640" aria-label="Witch's Potion Recipe Game Canvas"></canvas>
  </div>

  <div class="hud">
    <div class="score" id="score">점수 0 <span class="hi" id="hi">최고 0</span></div>
    <div class="topbar">
      <div class="timer" id="timer">60</div>
      <div class="lives" id="lives">❤️❤️❤️</div>
      <button class="iconbtn" id="settingsBtn" aria-label="게임 설정" style="display: none;">⚙️</button>
      <button class="iconbtn" id="infoBtn" aria-label="게임 정보" style="font-weight: 700; font-size: 16px; display: none;">i</button>
    </div>
    <div class="recipe-hud" id="recipe-hud"></div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
      <div class="title">마녀의 포션 레시피</div>
      <div class="sub">1분 안에 레시피를 최대한 많이 완성하세요!</div>
      <button class="btn" id="startBtn">게임 시작</button>
    </div>
  </div>
  
  <div class="overlay" id="infoOverlay" style="display:none;">
    <div class="panel">
      <div class="title">게임 방법</div>
      <div class="sub" style="text-align: left; line-height: 1.6;">
        - **1분**의 제한 시간 동안 최대한 많은 포션을 만드세요.<br>
        - 화면 상단의 레시피 순서에 맞는 재료가 중앙 마법진에 들어왔을 때 화면을 탭하세요.<br>
        - **순서가 틀리거나, 잘못된 재료**만 있을 때 탭하면 생명(❤️)이 줄어듭니다.<br>
        - 레시피를 완성하면 점수와 추가 시간을 얻습니다.
      </div>
      <button class="btn" id="infoCloseBtn">닫기</button>
    </div>
  </div>

  <div class="overlay" id="settingsOverlay" style="display:none;">
    <div class="panel">
      <div class="title">게임 설정</div>
      <div class="settings-grid">
        <label for="speedSlider">기본 속도</label>
        <input type="range" id="speedSlider" min="50" max="250" step="10" value="170">
        <span class="value" id="speedValue">170</span>

        <label for="accelSlider">속도 증가율</label>
        <input type="range" id="accelSlider" min="2" max="13" step="1" value="4">
        <span class="value" id="accelValue">4</span>

        <label for="spawnSlider">생성 간격</label>
        <input type="range" id="spawnSlider" min="0.3" max="2.5" step="0.1" value="1.0">
        <span class="value" id="spawnValue">1.0 s</span>
      </div>
      <button class="btn" id="settingsCloseBtn">저장하고 닫기</button>
    </div>
  </div>

  <script>
  let CFG = { 
    W: 360, H: 640, cauldronX: 180, cauldronY: 520, cauldronR: 80,
    targetZoneR: 60, lives: 3, gravity: 900, timeLimit: 60,
    baseSpeed: 100, speedPerSec: 2, spawnInterval: 1.5,
    starCount: 40, cloudCount: 5
  };

  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const livesEl = document.getElementById('lives');
  const recipeHud = document.getElementById('recipe-hud');
  const timerEl = document.getElementById('timer');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const infoBtn = document.getElementById('infoBtn');
  const infoOverlay = document.getElementById('infoOverlay');
  const infoCloseBtn = document.getElementById('infoCloseBtn');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsOverlay = document.getElementById('settingsOverlay');
  const settingsCloseBtn = document.getElementById('settingsCloseBtn');
  const speedSlider = document.getElementById('speedSlider');
  const speedValue = document.getElementById('speedValue');
  const accelSlider = document.getElementById('accelSlider');
  const accelValue = document.getElementById('accelValue');
  const spawnSlider = document.getElementById('spawnSlider');
  const spawnValue = document.getElementById('spawnValue');

  let DPR = Math.min(2, window.devicePixelRatio || 1);
  function fit(){ const ar = CFG.W/CFG.H; const vw = window.innerWidth, vh = window.innerHeight; let dw, dh; if (vw/vh > ar){ dh = vh; dw = vh*ar; } else { dw = vw; dh = vw/ar; } cv.style.width = dw+'px'; cv.style.height = dh+'px'; DPR = Math.min(2, window.devicePixelRatio||1); cv.width = Math.floor(CFG.W*DPR); cv.height = Math.floor(CFG.H*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
  window.addEventListener('resize', fit, { passive: true });
  
  let hiScore = Number(localStorage.getItem('hw3_hi')||0)||0; hiEl.textContent = `최고 ${hiScore}`;
  let running=false, dead=false, resumeAfterPause = false; let tPrev=0, elapsed=0, score=0, lives=CFG.lives;
  let spawnAcc = 0; let timeLeft = CFG.timeLimit;
  let idleLoopId;
  
  const ingredients = [];
  const particles = [];
  const bubbles = new Array(15).fill(0).map(() => ({ x: CFG.cauldronX + (Math.random() - 0.5) * CFG.cauldronR * 1.2, y: CFG.cauldronY, r: Math.random() * 5 + 2, speed: Math.random() * 30 + 20 }));
  const ingredientTypes = ['skull', 'batWing', 'frogLeg', 'eyeball', 'mushroom'];
  let currentRecipe = [];
  let recipeProgress = 0;
  
  const stars = new Array(CFG.starCount).fill(0).map(()=>({ x: Math.random()*CFG.W, y: Math.random()*CFG.H, s: 1 + Math.random()*1.5 }));
  const clouds = new Array(CFG.cloudCount).fill(0).map(()=>({ x: Math.random()*CFG.W, y: 50 + Math.random()*200, l: 50 + Math.random()*80, speed: 5 + Math.random()*10 }));

  const ingredientImages = {};

  function preloadImages() {
    const promises = ingredientTypes.map(type => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => { ingredientImages[type] = img; resolve(); };
        img.onerror = reject;
        img.src = `data:image/svg+xml,${encodeURIComponent(getIngredientSvg(type)).replace(/#/g, '%23')}`;
      });
    });
    return Promise.all(promises);
  }

  function loadSettings() {
    const saved = localStorage.getItem('hw3_settings');
    if (saved) {
      const userSettings = JSON.parse(saved);
      CFG = { ...CFG, ...userSettings };
    }
  }

  function updateSettingsUI() {
    speedSlider.value = CFG.baseSpeed;
    speedValue.textContent = CFG.baseSpeed;
    accelSlider.value = CFG.speedPerSec;
    accelValue.textContent = CFG.speedPerSec;
    spawnSlider.value = CFG.spawnInterval;
    spawnValue.textContent = `${CFG.spawnInterval.toFixed(1)} s`;
  }
  
  function saveSettings() {
    const userSettings = {
      baseSpeed: parseInt(speedSlider.value),
      speedPerSec: parseInt(accelSlider.value),
      spawnInterval: parseFloat(spawnSlider.value)
    };
    localStorage.setItem('hw3_settings', JSON.stringify(userSettings));
    CFG = { ...CFG, ...userSettings };
  }

  function generateRecipe() {
    recipeProgress = 0;
    const len = Math.min(5, 2 + Math.floor(score / 50));
    currentRecipe = new Array(len).fill(0).map(() => ingredientTypes[Math.floor(Math.random() * ingredientTypes.length)]);
    updateRecipeHud();
  }

  function updateRecipeHud() {
    recipeHud.innerHTML = '';
    currentRecipe.forEach((type, i) => {
      if (i > 0) {
        const separator = document.createElement('span');
        separator.className = 'separator';
        separator.textContent = '+';
        recipeHud.appendChild(separator);
      }
      const img = ingredientImages[type].cloneNode();
      img.className = 'icon';
      img.style.opacity = (i < recipeProgress) ? 0.3 : 1;
      recipeHud.appendChild(img);
    });
  }

  function onTap(e) {
    if (!running) return;
    e.preventDefault();
    const targetX = CFG.W / 2, targetY = CFG.H / 2;
    const ingredientsInCircle = ingredients.filter(item => {
      const dx = item.x - targetX, dy = item.y - targetY;
      return item.state === 'flying' && (dx*dx + dy*dy < CFG.targetZoneR * CFG.targetZoneR);
    });
    if (ingredientsInCircle.length === 0) return;
    const correctIngredient = ingredientsInCircle.find(item => item.type === currentRecipe[recipeProgress]);
    if (correctIngredient) {
      correctIngredient.state = 'falling';
      recipeProgress++;
      updateRecipeHud();
    } else {
      loseLife();
    }
  }
  
  cv.addEventListener('pointerdown', onTap, { passive: false });
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'Enter') {
      e.preventDefault();
      if(!running && !dead) start();
      else onTap(e);
    }
  });

  startBtn.addEventListener('click', ()=>start());
  overlay.addEventListener('click', ()=>{ if(!running && !dead) start(); });
  infoBtn.addEventListener('click', openInfo);
  infoCloseBtn.addEventListener('click', closeInfo);
  settingsBtn.addEventListener('click', openSettings);
  settingsCloseBtn.addEventListener('click', closeSettings);
  speedSlider.addEventListener('input', () => speedValue.textContent = speedSlider.value);
  accelSlider.addEventListener('input', () => accelValue.textContent = accelSlider.value);
  spawnSlider.addEventListener('input', () => spawnValue.textContent = `${parseFloat(spawnSlider.value).toFixed(1)} s`);

  function resetGame(){
    running=false; dead=false; elapsed=0; score=0; lives=CFG.lives;
    spawnAcc=0; timeLeft = CFG.timeLimit;
    ingredients.length=0; particles.length = 0;
    scoreEl.textContent = `점수 ${score} `; scoreEl.appendChild(hiEl);
    livesEl.textContent = '❤️'.repeat(CFG.lives);
    timerEl.textContent = timeLeft;
    generateRecipe();
  }

  function start(){
    if (idleLoopId) cancelAnimationFrame(idleLoopId);
    resetGame();
    running=true;
    overlay.style.display='none';
    tPrev=performance.now();
    requestAnimationFrame(loop);
  }
  
  function loseLife() {
    lives--;
    livesEl.textContent = '❤️'.repeat(lives) + '♡'.repeat(CFG.lives - lives);
    if (navigator.vibrate) navigator.vibrate(80);
    if (lives <= 0) gameOver();
  }

  function gameOver(){
    if(dead) return;
    dead=true; running=false;
    if(navigator.vibrate) navigator.vibrate(120);
    hiScore = Math.max(hiScore, score);
    localStorage.setItem('hw3_hi', String(hiScore));
    hiEl.textContent = `최고 ${hiScore}`;
    overlay.querySelector('.title').textContent = timeLeft <= 0 ? '시간 종료!' : '게임 오버';
    overlay.querySelector('.sub').textContent = `점수 ${score} · 최고 ${hiScore}`;
    startBtn.textContent='다시 시작';
    overlay.style.display='grid';
    idleLoop();
  }
  
  function openInfo(){ if(running && !dead){ running=false; resumeAfterPause=true; } infoOverlay.style.display='grid'; }
  function closeInfo(){ infoOverlay.style.display='none'; if(resumeAfterPause){ running=true; resumeAfterPause=false; tPrev=performance.now(); requestAnimationFrame(loop); } }
  function openSettings() { if(running && !dead){ running=false; resumeAfterPause=true; } settingsOverlay.style.display='grid'; }
  function closeSettings() { saveSettings(); settingsOverlay.style.display='none'; if(resumeAfterPause){ running=true; resumeAfterPause=false; tPrev=performance.now(); requestAnimationFrame(loop); } }
  
  function createSplash(x, y) {
    for(let i=0; i<20; i++) {
      const angle = Math.random() * Math.PI * 2;
      const power = Math.random() * 200 + 100;
      particles.push({ x, y, vx: Math.cos(angle) * power, vy: Math.sin(angle) * power, r: Math.random() * 3 + 1, life: 1 });
    }
  }
  
  function idleLoop(t = 0) {
    updateBubbles(0.016);
    updateClouds(0.016);
    draw(t);
    idleLoopId = requestAnimationFrame(idleLoop);
  }

  function loop(t){
    if(!running) return;
    const dt = Math.min(0.033, (t - tPrev)/1000);
    tPrev=t;
    update(dt);
    draw(t);
    requestAnimationFrame(loop);
  }
  
  function updateBubbles(dt) {
      for(const bubble of bubbles) {
        bubble.y -= bubble.speed * dt;
        if (bubble.y < CFG.cauldronY - 50) {
            bubble.y = CFG.cauldronY;
            bubble.x = CFG.cauldronX + (Math.random() - 0.5) * CFG.cauldronR * 1.2;
        }
    }
  }
  
  function updateClouds(dt) {
      for (const cloud of clouds) {
        cloud.x -= cloud.speed * dt;
        if (cloud.x < -cloud.l) cloud.x = CFG.W + cloud.l;
    }
  }

  function update(dt){
    elapsed += dt;
    timeLeft -= dt;
    if (timeLeft <= 0) {
      timeLeft = 0;
      gameOver();
    }
    timerEl.textContent = Math.ceil(timeLeft);

    spawnAcc += dt;
    updateBubbles(dt);
    updateClouds(dt);
    const spawnInterval = Math.max(0.5, CFG.spawnInterval - elapsed * 0.02);
    if (spawnAcc > spawnInterval){
      spawnAcc = 0;
      const type = ingredientTypes[Math.floor(Math.random() * ingredientTypes.length)];
      const angle = Math.random() * Math.PI * 2;
      const startX = CFG.W/2 + Math.cos(angle) * (CFG.W/2 + 40);
      const startY = CFG.H/2 + Math.sin(angle) * (CFG.H/2 + 40);
      const speed = CFG.baseSpeed + Math.random() * 40 + elapsed * CFG.speedPerSec;
      const targetX = CFG.W/2 + (Math.random() - 0.5) * 100;
      const targetY = CFG.H/2 + (Math.random() - 0.5) * 100;
      const moveAngle = Math.atan2(targetY - startY, targetX - startX);
      
      ingredients.push({ x: startX, y: startY, r: 20, type, state: 'flying', vx: Math.cos(moveAngle) * speed, vy: Math.sin(moveAngle) * speed, life: 6 });
    }

    for (let i=ingredients.length-1; i>=0; i--){
      const item = ingredients[i];
      if (item.state === 'flying') {
        item.x += item.vx * dt;
        item.y += item.vy * dt;
        item.life -= dt;
        if(item.life < 0) { ingredients.splice(i, 1); }
      } else if (item.state === 'falling') {
        item.vy += CFG.gravity * dt;
        item.y += item.vy * dt;
        if (item.y > CFG.cauldronY - 20) {
          createSplash(item.x, item.y);
          ingredients.splice(i, 1);
          if (recipeProgress === currentRecipe.length) {
            score += 10;
            timeLeft += 3;
            timerEl.textContent = Math.ceil(timeLeft);
            scoreEl.childNodes[0].nodeValue = `점수 ${score} `;
            generateRecipe();
          }
        }
      }
    }
    
    for(let i=particles.length-1; i>=0; i--) {
      const p = particles[i];
      p.vy += CFG.gravity * dt * 0.5;
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  function drawCauldron(t) {
    const {cauldronX, cauldronY, cauldronR} = CFG;
    ctx.fillStyle = '#222';
    ctx.fillRect(cauldronX - cauldronR*0.8, cauldronY, 20, 80);
    ctx.fillRect(cauldronX + cauldronR*0.8 - 20, cauldronY, 20, 80);
    const grad = ctx.createRadialGradient(cauldronX, cauldronY, 0, cauldronX, cauldronY, cauldronR);
    grad.addColorStop(0, '#333'); grad.addColorStop(1, '#111');
    ctx.fillStyle = grad;
    circle(cauldronX, cauldronY, cauldronR);
    ctx.fillStyle = '#444';
    ctx.beginPath(); ctx.ellipse(cauldronX, cauldronY - cauldronR*0.8, cauldronR, 20, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#5eff00'; ctx.shadowColor = '#5eff00'; ctx.shadowBlur = 20;
    ctx.beginPath(); ctx.ellipse(cauldronX, cauldronY - cauldronR*0.8, cauldronR*0.9, 18, 0, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    for(const b of bubbles) {
      const life = (CFG.cauldronY - b.y) / 50;
      ctx.fillStyle = `rgba(173, 255, 47, ${1 - life})`;
      circle(b.x, b.y, b.r * life);
    }
  }

  function drawMagicCircle(t) {
    const {W, H, targetZoneR} = CFG;
    const x = W/2, y = H/2;
    ctx.save(); ctx.translate(x, y);
    ctx.strokeStyle = `rgba(182, 109, 255, ${0.3 + Math.sin(t/300) * 0.2})`;
    ctx.lineWidth = 6;
    ctx.shadowColor = '#b66dff'; ctx.shadowBlur = 20;
    ctx.beginPath(); ctx.arc(0, 0, targetZoneR, 0, Math.PI*2); ctx.stroke();
    ctx.rotate(t / 1000);
    ctx.strokeStyle = `rgba(182, 109, 255, ${0.5 + Math.sin(t/200) * 0.3})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0; i < 6; i++) {
        const angle = (i/5) * Math.PI * 2;
        ctx.lineTo(Math.cos(angle) * targetZoneR * 0.8, Math.sin(angle) * targetZoneR * 0.8);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
    ctx.shadowBlur = 0;
  }
  
  function drawBackground(t){
    ctx.clearRect(0,0,CFG.W,CFG.H);
    for(const star of stars) {
        ctx.fillStyle = `rgba(255,255,255,${0.5 + star.s/3})`;
        ctx.fillRect(star.x, star.y, star.s, star.s);
    }
    const moonGrad = ctx.createRadialGradient(CFG.W-80, 80, 20, CFG.W-80, 80, 50);
    moonGrad.addColorStop(0, '#f0e68c');
    moonGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = moonGrad;
    circle(CFG.W - 80, 80, 50);
    for(const cloud of clouds) {
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        ctx.beginPath();
        ctx.ellipse(cloud.x, cloud.y, cloud.l, cloud.l*0.2, 0, 0, Math.PI*2);
        ctx.fill();
    }
    ctx.fillStyle = '#0b0f19';
    ctx.beginPath();
    ctx.moveTo(0, CFG.H);
    ctx.lineTo(0, CFG.H - 50);
    ctx.quadraticCurveTo(CFG.W*0.2, CFG.H-80, CFG.W*0.5, CFG.H-40);
    ctx.quadraticCurveTo(CFG.W*0.8, CFG.H-20, CFG.W, CFG.H-60);
    ctx.lineTo(CFG.W, CFG.H);
    ctx.closePath();
    ctx.fill();
  }

  function getIngredientSvg(type) {
    switch(type) {
      case 'skull': return `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g fill="#f0e68c"><path d="M25 30 Q 50 10 75 30 L 75 70 Q 50 90 25 70 Z"/><rect x="30" y="70" width="40" height="15" rx="5"/></g><g fill="#222"><circle cx="40" cy="50" r="10"/><circle cx="60" cy="50" r="10"/><path d="M45 65 L 55 65 L 50 75 Z"/><rect x="35" y="75" width="30" height="3"/><rect x="38" y="78" width="24" height="3"/></g></svg>`;
      case 'batWing': return `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M20 50 C 30 20, 70 20, 80 40 L 80 60 C 70 80, 30 80, 20 50 Z" fill="#4b2a9e"/><path d="M25 50 C 40 35, 60 35, 75 45" stroke="#2c1066" stroke-width="4" fill="none"/></svg>`;
      case 'frogLeg': return `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g stroke="#228B22" stroke-width="10" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M60 20 L 40 50 L 50 80"/><path d="M50 80 L 30 90 M50 80 L 50 95 M50 80 L 70 90"/></g></svg>`;
      case 'eyeball': return `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="40" fill="#fff"/><circle cx="50" cy="50" r="25" fill="#87CEEB"/><circle cx="50" cy="50" r="12" fill="#000"/><g stroke="#ff3b30" stroke-width="3"><path d="M50 10 Q 40 25 20 20"/><path d="M90 50 Q 70 40 65 25"/><path d="M15 70 Q 30 75 20 90"/></g></svg>`;
      case 'mushroom': return `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M10 60 C 10 30, 90 30, 90 60 Z" fill="#ff4500"/><rect x="40" y="60" width="20" height="30" fill="#f0e68c"/><g fill="#fff"><circle cx="50" cy="35" r="8"/><circle cx="30" cy="50" r="6"/><circle cx="70" cy="50" r="6"/></g></svg>`;
    }
  }

  function drawIngredient(item) {
    const img = ingredientImages[item.type];
    if (!img || !img.complete) return; 

    ctx.save();
    ctx.translate(item.x, item.y);
    ctx.rotate(Math.atan2(item.vy, item.vx) + Math.PI/2);
    ctx.globalAlpha = Math.min(1, item.life);
    ctx.drawImage(img, -item.r, -item.r, item.r*2, item.r*2);
    ctx.restore();
  }
  
  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
  
  function draw(t) {
    drawBackground(t);
    drawMagicCircle(t);
    for(const item of ingredients) {
      drawIngredient(item);
    }
    drawCauldron(t);
    for(const p of particles) {
      ctx.fillStyle = `rgba(173, 255, 47, ${p.life})`;
      circle(p.x, p.y, p.r);
    }
  }
  
  async function main() {
    overlay.querySelector('.sub').textContent = '로딩 중...';
    startBtn.style.display = 'none';
    
    try {
      await preloadImages();
      
      overlay.querySelector('.sub').textContent = '1분 안에 레시피를 최대한 많이 완성하세요!';
      startBtn.style.display = 'block';

      loadSettings();
      updateSettingsUI();
      fit();
      resetGame();
      idleLoop();

      infoBtn.style.display = 'grid';
      settingsBtn.style.display = 'grid';
    } catch(e) {
      overlay.querySelector('.sub').textContent = '이미지를 불러오는 데 실패했습니다. 새로고침 해주세요.';
      console.error("Image preloading failed:", e);
    }
  }

  main();
  </script>
</body>
</html>