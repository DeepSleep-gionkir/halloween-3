<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Halloween Candy Catch Game</title>
  <style>
    :root {
      --bg0: #0b0f19;
      --bg1: #0f1330;
      --accent: #ff7a00;
      --accent2: #b66dff;
      --accent3: #c9f;
      --danger: #ff3b30;
      --text: #e9e9f0;
    }

    html, body { height: 100%; margin: 0; background: radial-gradient(120% 120% at 50% 0%, var(--bg1), var(--bg0)); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Arial, Apple Color Emoji, Segoe UI Emoji; overscroll-behavior: none; }

    .wrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas { display: block; background: transparent; touch-action: none; cursor: pointer; }

    .hud { position: fixed; inset: 0; pointer-events: none; z-index: 3;}
    .score { position: absolute; top: env(safe-area-inset-top, 12px); left: 12px; padding: 6px 10px; border-radius: 10px; backdrop-filter: blur(6px); background: #0006; font-weight: 700; letter-spacing: 0.5px; box-shadow: 0 4px 16px #0007; user-select: none; }
    .hi { margin-left: 8px; opacity: .75; font-weight: 600; }

    .topbar { position: fixed; top: env(safe-area-inset-top, 12px); right: 12px; display: flex; gap: 8px; pointer-events: auto; z-index: 5; }
    .iconbtn { appearance: none; border: 0; width: 36px; height: 36px; border-radius: 50%; background: radial-gradient(120% 120% at 30% 20%, #7f5cff, #4a2fff); color: #fff; font-size: 18px; font-weight: 900; cursor: pointer; box-shadow: 0 6px 16px #0008, inset 0 0 0 1px #ffffff33; display: grid; place-items: center; }
    .iconbtn:active { transform: translateY(1px); }

    .overlay { position: fixed; inset: 0; display: none; place-items: center; background: linear-gradient(180deg, #0008, #0004); backdrop-filter: blur(3px); z-index: 4; }
    .panel { pointer-events: auto; text-align: center; padding: 18px 20px; border-radius: 16px; background: #0c112480; border: 1px solid #ffffff18; box-shadow: 0 10px 30px #0009; max-width: min(90vw, 420px); }
    .title { font-size: 18px; margin-bottom: 10px; font-weight: 800; }
    .sub { opacity: .8; font-size: 13px; margin-bottom: 14px; }
    .btn { margin-top: 6px; appearance: none; border: 0; border-radius: 14px; background: linear-gradient(180deg, var(--accent2), #6a37ff); color: white; padding: 12px 16px; font-weight: 800; letter-spacing: .4px; cursor: pointer; box-shadow: 0 8px 18px #652bff55, inset 0 0 0 1px #ffffff30; }
    .btn:active { transform: translateY(1px); }

    .settings-grid { display: grid; grid-template-columns: auto 1fr auto; gap: 10px 15px; align-items: center; text-align: left; margin: 20px 0; font-size: 13px; }
    .settings-grid label { font-weight: 600; opacity: 0.9; }
    .settings-grid .value { font-weight: 700; color: var(--accent3); min-width: 40px; text-align: right; }
    input[type=range] { width: 100%; height: 6px; background: #0005; border-radius: 3px; cursor: pointer; appearance: none; }
    input[type=range]::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--accent2); border: 2px solid #fff; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="cv" width="360" height="640" aria-label="Halloween candy catch game canvas"></canvas>
  </div>

  <div class="hud">
    <div class="score" id="score">점수 0 <span class="hi" id="hi">최고 0</span></div>
  </div>

  <div class="topbar">
    <button class="iconbtn" id="settingsBtn" aria-label="게임 설정">⚙️</button>
    <button class="iconbtn" id="infoBtn" aria-label="게임 정보" style="font-weight: 700; font-size: 16px;">i</button>
  </div>

  <div class="overlay" id="overlay" style="display:grid;">
    <div class="panel">
      <div class="title">잭오랜턴 사탕 담기</div>
      <div class="sub">하늘에서 떨어지는 사탕을 받고, 유령과 폭탄은 피하세요!</div>
      <button class="btn" id="startBtn">게임 시작</button>
    </div>
  </div>
  
  <div class="overlay" id="infoOverlay">
    <div class="panel">
      <div class="title">게임 방법</div>
      <div class="sub" style="text-align: left; line-height: 1.6;">
        - 마우스(클릭&드래그)나 손가락으로 바구니를 움직이세요.<br>
        - PC에서는 키보드 좌우(←, →) 방향키로도 조작할 수 있습니다.<br>
        - <strong>사탕</strong>을 받으면 점수가 오릅니다.<br>
        - <strong>사탕을 놓치거나, 유령/폭탄</strong>을 받으면 게임이 종료됩니다.
      </div>
      <button class="btn" id="infoCloseBtn">닫기</button>
    </div>
  </div>

  <div class="overlay" id="settingsOverlay">
    <div class="panel">
      <div class="title">난이도 설정</div>
      <div class="settings-grid">
        <label for="speedSlider">시작 속도</label>
        <input type="range" id="speedSlider" min="80" max="500" step="10" value="240">
        <span class="value" id="speedValue">240</span>

        <label for="accelSlider">속도 증가율</label>
        <input type="range" id="accelSlider" min="1" max="25" step="1" value="6">
        <span class="value" id="accelValue">6</span>

        <label for="spawnSlider">생성 간격</label>
        <input type="range" id="spawnSlider" min="300" max="2000" step="50" value="1400">
        <span class="value" id="spawnValue">1400 ms</span>

        <label for="badItemSlider">장애물 확률</label>
        <input type="range" id="badItemSlider" min="10" max="60" step="1" value="30">
        <span class="value" id="badItemValue">30 %</span>
      </div>
      <button class="btn" id="settingsCloseBtn">저장하고 닫기</button>
    </div>
  </div>

  <script>
  let CFG = { 
    W: 360, H: 640, basketW: 90, basketH: 75, basketY: 570, 
    baseFallSpeed: 120, speedPerSec: 6, 
    spawnBaseMs: 1400, spawnMinMs: 500, 
    baseBadItemChance: 0.2,
    starCount: 40, cloudCount: 5
  };

  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const infoBtn = document.getElementById('infoBtn');
  const infoOverlay = document.getElementById('infoOverlay');
  const infoCloseBtn = document.getElementById('infoCloseBtn');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsOverlay = document.getElementById('settingsOverlay');
  const settingsCloseBtn = document.getElementById('settingsCloseBtn');
  const speedSlider = document.getElementById('speedSlider');
  const speedValue = document.getElementById('speedValue');
  const accelSlider = document.getElementById('accelSlider');
  const accelValue = document.getElementById('accelValue');
  const spawnSlider = document.getElementById('spawnSlider');
  const spawnValue = document.getElementById('spawnValue');
  const badItemSlider = document.getElementById('badItemSlider');
  const badItemValue = document.getElementById('badItemValue');

  let DPR = Math.min(2, window.devicePixelRatio || 1);
  function fit(){ const ar = CFG.W/CFG.H; const vw = window.innerWidth, vh = window.innerHeight; let dw, dh; if (vw/vh > ar){ dh = vh; dw = vh*ar; } else { dw = vw; dh = vw/ar; } cv.style.width = dw+'px'; cv.style.height = dh+'px'; DPR = Math.min(2, window.devicePixelRatio||1); cv.width = Math.floor(CFG.W*DPR); cv.height = Math.floor(CFG.H*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
  window.addEventListener('resize', fit, { passive: true });
  
  let hiScore = Number(localStorage.getItem('hw2_hi')||0)||0; hiEl.textContent = `최고 ${hiScore}`;
  let running=false, dead=false, resumeAfterPause=false; let tPrev=0, elapsed=0, score=0;
  let fallSpeed=CFG.baseFallSpeed, spawnMs=CFG.spawnBaseMs, spawnAcc=0;
  let basketFlashUntil = 0;
  const player = { x: CFG.W/2, prevX: CFG.W/2, y: CFG.basketY, w: CFG.basketW, h: CFG.basketH, vx: 0, tilt: 0 };
  const items = [];
  const keys = new Set();
  const candyTypes = ['candyCorn', 'wrappedCandy', 'lollipop', 'chocolateBar', 'ghostPeep'];
  const badTypes = ['whiteGhost', 'bomb'];
  let lastGoodItemType = '';
  let isPointerDown = false;
  
  const stars = new Array(CFG.starCount).fill(0).map(()=>({ x: Math.random()*CFG.W, y: Math.random()*CFG.H, s: 1 + Math.random()*1.5 }));
  const clouds = new Array(CFG.cloudCount).fill(0).map(()=>({ x: Math.random()*CFG.W, y: 50 + Math.random()*200, l: 50 + Math.random()*80, speed: 5 + Math.random()*10 }));

  function loadSettings() {
    const saved = localStorage.getItem('hw2_settings');
    if (saved) {
      const userSettings = JSON.parse(saved);
      CFG = { ...CFG, ...userSettings };
    }
  }

  function updateSettingsUI() {
    speedSlider.value = CFG.baseFallSpeed;
    speedValue.textContent = CFG.baseFallSpeed;
    accelSlider.value = CFG.speedPerSec;
    accelValue.textContent = CFG.speedPerSec;
    spawnSlider.value = CFG.spawnBaseMs;
    spawnValue.textContent = `${CFG.spawnBaseMs} ms`;
    badItemSlider.value = CFG.baseBadItemChance * 100;
    badItemValue.textContent = `${Math.round(CFG.baseBadItemChance * 100)} %`;
  }
  
  function saveSettings() {
    const userSettings = {
      baseFallSpeed: parseInt(speedSlider.value),
      speedPerSec: parseInt(accelSlider.value),
      spawnBaseMs: parseInt(spawnSlider.value),
      baseBadItemChance: parseInt(badItemSlider.value) / 100
    };
    localStorage.setItem('hw2_settings', JSON.stringify(userSettings));
    CFG = { ...CFG, ...userSettings };
  }

  function handlePointerMove(e) {
    const rect = cv.getBoundingClientRect();
    const scaleX = cv.width / (rect.width * DPR);
    player.x = (e.clientX - rect.left) * scaleX;
  }
  
  cv.addEventListener('pointerdown', (e) => { isPointerDown = true; handlePointerMove(e); }, { passive: true });
  window.addEventListener('pointerup', () => { isPointerDown = false; }, { passive: true });
  cv.addEventListener('pointermove', (e) => { if (isPointerDown) { handlePointerMove(e); } }, { passive: true });
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') { e.preventDefault(); keys.add(e.code); }
    if(!running && (e.code==='Space'||e.code==='Enter')) start();
  });
  window.addEventListener('keyup', (e) => keys.delete(e.code));
  
  startBtn.addEventListener('click', ()=>start());
  overlay.addEventListener('click', ()=>{ if(!running && !dead) start(); });
  infoBtn.addEventListener('click', openInfo);
  infoCloseBtn.addEventListener('click', closeInfo);
  settingsBtn.addEventListener('click', openSettings);
  settingsCloseBtn.addEventListener('click', closeSettings);
  speedSlider.addEventListener('input', () => speedValue.textContent = speedSlider.value);
  accelSlider.addEventListener('input', () => accelValue.textContent = accelSlider.value);
  spawnSlider.addEventListener('input', () => spawnValue.textContent = `${spawnSlider.value} ms`);
  badItemSlider.addEventListener('input', () => badItemValue.textContent = `${badItemSlider.value} %`);

  function resetGame(){
    running=false; dead=false; elapsed=0; score=0;
    fallSpeed=CFG.baseFallSpeed; spawnMs=CFG.spawnBaseMs; spawnAcc=0;
    items.length=0; player.x=CFG.W/2; player.vx = 0; player.tilt = 0; player.prevX = CFG.W/2;
    lastGoodItemType = ''; isPointerDown = false;
    scoreEl.textContent = `점수 0 `; scoreEl.appendChild(hiEl);
  }

  function start(){ resetGame(); running=true; overlay.style.display='none'; tPrev=performance.now(); requestAnimationFrame(loop); }
  function gameOver(){
    if(dead) return;
    dead=true; running=false;
    if(navigator.vibrate) navigator.vibrate(120);
    hiScore = Math.max(hiScore, score);
    localStorage.setItem('hw2_hi', String(hiScore));
    hiEl.textContent = `최고 ${hiScore}`;
    overlay.querySelector('.title').textContent='게임 오버';
    overlay.querySelector('.sub').textContent = `점수 ${score} · 최고 ${hiScore}`;
    startBtn.textContent='다시 시작';
    overlay.style.display='grid';
  }
  
  function openInfo(){ resumeAfterPause = running && !dead; if(resumeAfterPause) running=false; infoOverlay.style.display='grid'; }
  function closeInfo(){ infoOverlay.style.display='none'; if(resumeAfterPause && !dead){ running=true; tPrev=performance.now(); requestAnimationFrame(loop); } }
  function openSettings() { resumeAfterPause = running && !dead; if(resumeAfterPause) running=false; settingsOverlay.style.display='grid'; }
  function closeSettings() { saveSettings(); settingsOverlay.style.display='none'; if(resumeAfterPause && !dead){ running=true; tPrev=performance.now(); requestAnimationFrame(loop); } }
  
  function flashBasket(ms) {
    basketFlashUntil = performance.now() + ms;
  }

  function loop(t){
    if(!running) return;
    const dt = Math.min(0.033, (t - tPrev)/1000);
    tPrev=t; update(dt); draw(t); requestAnimationFrame(loop);
  }

  function update(dt){
    elapsed += dt;
    fallSpeed = CFG.baseFallSpeed + elapsed * CFG.speedPerSec;
    
    // [수정] 이 부분의 숫자를 높여 간격 감소를 더 빠르게 합니다.
    const targetSpawn = Math.max(CFG.spawnMinMs, CFG.spawnBaseMs - elapsed * 40);
    spawnMs = (spawnMs * 0.98) + (targetSpawn * 0.02);
    
    if (keys.has('ArrowLeft')) player.x -= 300 * dt;
    if (keys.has('ArrowRight')) player.x += 300 * dt;
    player.x = Math.max(player.w/2, Math.min(CFG.W - player.w/2, player.x));
    player.vx = player.x - player.prevX;
    player.prevX = player.x;
    player.tilt = (player.tilt * 0.85) + (player.vx * 0.02);

    for (const cloud of clouds) {
      cloud.x -= cloud.speed * dt;
      if (cloud.x < -cloud.l) cloud.x = CFG.W + cloud.l;
    }

    spawnAcc += dt*1000;
    if (spawnAcc >= spawnMs){
      spawnAcc=0;
      const x = 20 + Math.random()*(CFG.W - 40);
      const r = 12 + Math.random() * 6;
      const isBad = Math.random() < CFG.baseBadItemChance + elapsed * 0.005;
      let type;
      if (isBad) {
        type = badTypes[Math.floor(Math.random() * badTypes.length)];
      } else {
        const availableCandies = candyTypes.filter(t => t !== lastGoodItemType);
        type = availableCandies[Math.floor(Math.random() * availableCandies.length)];
        lastGoodItemType = type;
      }
      items.push({ x, y: -r*2, r, type, angle: Math.random() * Math.PI*2 });
    }

    for (let i=items.length-1; i>=0; i--){
      const item = items[i];
      item.y += fallSpeed * dt;
      item.angle += dt * 2;
      const collides = item.x > player.x - player.w/2 && item.x < player.x + player.w/2 &&
                       item.y > player.y - player.h/2 && item.y < player.y + player.h;
      
      if (collides) {
        if (!badTypes.includes(item.type)) { 
          score++; 
          scoreEl.childNodes[0].nodeValue = `점수 ${score} `;
          flashBasket(150);
        } 
        else { gameOver(); }
        items.splice(i, 1);
        continue;
      }
      
      if (item.y > player.y && !badTypes.includes(item.type)) {
          gameOver();
          items.splice(i, 1);
          continue;
      }

      if(item.y > CFG.H + 50) {
        items.splice(i, 1);
      }
    }
  }

  function drawBasket(p){
    const {x,y,w,h,tilt}=p;
    ctx.save(); ctx.translate(x,y); ctx.rotate(tilt);
    
    if (performance.now() < basketFlashUntil) {
      const glowSize = w * 0.8;
      const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
      grad.addColorStop(0, 'rgba(255, 255, 224, 0.7)');
      grad.addColorStop(1, 'rgba(255, 255, 224, 0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
      ctx.fill();
    }

    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, w*0.6);
    grad.addColorStop(0, '#ff9a20'); grad.addColorStop(1, '#e56a00');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.ellipse(0, 0, w/2, h/2, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#c35a0099'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, -h/2); ctx.quadraticCurveTo(w*0.4, 0, 0, h/2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, -h/2); ctx.quadraticCurveTo(-w*0.4, 0, 0, h/2); ctx.stroke();
    ctx.fillStyle = '#6a4a33'; ctx.fillRect(-w*0.1, -h*0.6, w*0.2, h*0.2);
    ctx.fillStyle = '#ffdd00'; ctx.shadowColor = '#ffdd00'; ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.moveTo(-w*0.28, -h*0.1); ctx.lineTo(-w*0.12, -h*0.25); ctx.lineTo(-w*0.25, -h*0.35); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(w*0.28, -h*0.1); ctx.lineTo(w*0.12, -h*0.25); ctx.lineTo(w*0.25, -h*0.35); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(-w*0.2, h*0.15); ctx.lineTo(-w*0.1, h*0.3); ctx.lineTo(w*0.1, h*0.3); ctx.lineTo(w*0.2, h*0.15); ctx.closePath(); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#c35a00'; ctx.beginPath(); ctx.ellipse(0, -h*0.4, w*0.44, h*0.18, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#00000088'; ctx.beginPath(); ctx.ellipse(0, -h*0.4, w*0.4, h*0.15, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  
  function drawWhiteGhost(item) {
    const {x, y, r} = item;
    const sway = Math.sin(y / 20) * r * 0.3;
    ctx.save();
    ctx.translate(x + sway, y);
    const w = r*2, h = r*2.5;
    ctx.beginPath();
    ctx.moveTo(-w/2, -h*0.1);
    ctx.quadraticCurveTo(0, -h*0.6, w/2, -h*0.1);
    ctx.lineTo(w*0.4, h*0.4);
    ctx.quadraticCurveTo(w*0.2, h*0.2, 0, h*0.5);
    ctx.quadraticCurveTo(-w*0.2, h*0.2, -w*0.4, h*0.4);
    ctx.closePath();
    ctx.fillStyle = '#ffffffcc';
    ctx.fill();
    ctx.fillStyle = '#333';
    circle(-w*0.15, -h*0.15, r*0.2);
    circle(w*0.15, -h*0.15, r*0.2);
    ctx.restore();
  }
  
  function drawBomb(item) {
    const {x,y,r,angle}=item;
    ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
    const glowSize = r * 2.5 + Math.sin(elapsed * 10) * r * 0.5;
    const gradGlow = ctx.createRadialGradient(0,0,0,0,0,glowSize);
    gradGlow.addColorStop(0, '#ff3b3088'); gradGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = gradGlow; circle(0,0, glowSize);
    ctx.fillStyle = '#111'; circle(0,0,r*1.5);
    ctx.fillStyle = '#444'; ctx.beginPath(); ctx.arc(-r*0.5, -r*0.5, r*0.8, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#222'; ctx.lineWidth = r*0.3;
    ctx.beginPath(); ctx.moveTo(0, -r*1.2); ctx.quadraticCurveTo(r*0.5, -r*1.8, r*0.8, -r*1.6); ctx.stroke();
    if (Math.random() > 0.3) {
      const sparkX = r*0.8, sparkY = -r*1.6;
      ctx.fillStyle = '#ffdd00'; ctx.shadowColor = '#ffdd00'; ctx.shadowBlur = 8;
      ctx.beginPath(); ctx.arc(sparkX, sparkY, r*0.4, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.restore();
  }

  function drawCandyCorn(item) { const {x,y,r,angle}=item; ctx.save(); ctx.translate(x,y); ctx.rotate(angle); const h = r * 2.5; const w = r * 2; ctx.beginPath(); ctx.moveTo(-w/2, -h/3); ctx.lineTo(w/2, -h/3); ctx.lineTo(0, (h*2)/3); ctx.closePath(); ctx.fillStyle = '#fff'; ctx.fill(); ctx.beginPath(); ctx.moveTo(-w/2, -h/3); ctx.lineTo(w/2, -h/3); ctx.lineTo(0, 0); ctx.closePath(); ctx.fillStyle = '#ff7a00'; ctx.fill(); ctx.beginPath(); ctx.moveTo(-w/2 * 0.5, 0); ctx.lineTo(w/2 * 0.5, 0); ctx.lineTo(0, h/3); ctx.closePath(); ctx.fillStyle = '#ffc700'; ctx.fill(); ctx.restore(); }
  function drawWrappedCandy(item) { const {x,y,r,angle}=item; ctx.save(); ctx.translate(x,y); ctx.rotate(angle); ctx.fillStyle = '#8a4fff'; roundRect(-r*1.2, -r*0.8, r*2.4, r*1.6, r*0.5); ctx.fillStyle = '#6a37ff'; ctx.beginPath(); ctx.moveTo(-r*1.1, 0); ctx.lineTo(-r*2, -r*0.7); ctx.lineTo(-r*2, r*0.7); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(r*1.1, 0); ctx.lineTo(r*2, -r*0.7); ctx.lineTo(r*2, r*0.7); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#ffffff88'; roundRect(-r, -r*0.5, r*2, r*0.3, r*0.15); ctx.restore(); }
  function drawLollipop(item) { const {x,y,r,angle}=item; ctx.save(); ctx.translate(x,y); ctx.rotate(angle); ctx.fillStyle = '#fff'; ctx.fillRect(-r*0.2, 0, r*0.4, r*2.5); const grad = ctx.createRadialGradient(0,0,0,0,0,r); grad.addColorStop(0, '#ff69b4'); grad.addColorStop(1, '#f00'); ctx.fillStyle = grad; circle(0,0,r*1.2); ctx.strokeStyle = '#fff'; ctx.lineWidth = r*0.2; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  function drawChocolateBar(item) { const {x,y,r,angle}=item; ctx.save(); ctx.translate(x,y); ctx.rotate(angle); const w = r*1.5, h = r*2.5; ctx.fillStyle = '#7b3f00'; roundRect(-w/2, -h/2, w, h, w*0.1); ctx.strokeStyle = '#5b2e00'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(-w/2, 0); ctx.lineTo(w/2, 0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, -h/2); ctx.lineTo(0, h/2); ctx.stroke(); ctx.restore(); }
  function drawGhostPeep(item) { const {x,y,r,angle}=item; ctx.save(); ctx.translate(x,y); ctx.rotate(angle); const w = r*1.8, h = r*2; ctx.beginPath(); ctx.arc(0, -h*0.1, w/2, Math.PI, 0); ctx.quadraticCurveTo(w*0.7, h*0.4, 0, h*0.5); ctx.quadraticCurveTo(-w*0.7, h*0.4, -w/2, -h*0.1); ctx.closePath(); ctx.fillStyle = '#fff'; ctx.fill(); ctx.fillStyle = '#333'; circle(-w*0.15, -h*0.15, r*0.1); circle(w*0.15, -h*0.15, r*0.1); ctx.restore(); }

  function drawBackground(t){
    ctx.clearRect(0,0,CFG.W,CFG.H);
    for(const star of stars) {
        ctx.fillStyle = `rgba(255,255,255,${0.5 + star.s/3})`;
        ctx.fillRect(star.x, star.y, star.s, star.s);
    }
    const moonGrad = ctx.createRadialGradient(CFG.W-80, 80, 20, CFG.W-80, 80, 50);
    moonGrad.addColorStop(0, '#f0e68c');
    moonGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = moonGrad;
    circle(CFG.W - 80, 80, 50);
    for(const cloud of clouds) {
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        ctx.beginPath();
        ctx.ellipse(cloud.x, cloud.y, cloud.l, cloud.l*0.2, 0, 0, Math.PI*2);
        ctx.fill();
    }
    ctx.fillStyle = '#0b0f19';
    ctx.beginPath();
    ctx.moveTo(0, CFG.H);
    ctx.lineTo(0, CFG.H - 50);
    ctx.quadraticCurveTo(CFG.W*0.2, CFG.H-80, CFG.W*0.5, CFG.H-40);
    ctx.quadraticCurveTo(CFG.W*0.8, CFG.H-20, CFG.W, CFG.H-60);
    ctx.lineTo(CFG.W, CFG.H);
    ctx.closePath();
    ctx.fill();
  }

  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
  function roundRect(x,y,w,h,r){ const rr=Math.min(r, Math.abs(w)/2, Math.abs(h)/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); ctx.fill(); }
  
  function draw(t){
    drawBackground(t);
    for(const item of items) {
      if (item.type === 'candyCorn') drawCandyCorn(item);
      else if (item.type === 'wrappedCandy') drawWrappedCandy(item);
      else if (item.type === 'lollipop') drawLollipop(item);
      else if (item.type === 'chocolateBar') drawChocolateBar(item);
      else if (item.type === 'ghostPeep') drawGhostPeep(item);
      else if (item.type === 'whiteGhost') drawWhiteGhost(item);
      else if (item.type === 'bomb') drawBomb(item);
    }
    drawBasket(player);
  }

  loadSettings();
  updateSettingsUI();
  fit();
  draw();
  </script>
</body>
</html>